pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  parameters {
    choice(name: 'PROMOTE_TO', choices: ['qa', 'prod'], description: 'Target environment to promote to')
    string(name: 'GIT_REF', defaultValue: 'main', description: 'Git ref to deploy (commit SHA, tag, or branch). Recommend a commit SHA.')
    string(name: 'AWS_REGION', defaultValue: 'us-east-1', description: 'AWS region')
    booleanParam(name: 'AUTO_APPROVE', defaultValue: false, description: 'Auto-approve apply (NOT recommended, especially for prod)')
  }

  environment {
    TF_IN_AUTOMATION = 'true'
    TF_INPUT         = 'false'
  }

  stages {
    stage('Checkout ref') {
  steps {
    checkout scm
    script {
      sh """
        set -e
        git fetch --all --tags --prune

        # If GIT_REF is a branch like 'main', force it to the latest origin/<branch>
        if git show-ref --verify --quiet "refs/remotes/origin/${params.GIT_REF}"; then
          git checkout -f ${params.GIT_REF}
          git reset --hard origin/${params.GIT_REF}
        else
          # Otherwise assume it's a tag or commit SHA
          git checkout -f ${params.GIT_REF}
        fi

        git rev-parse HEAD > .git_commit
      """

      env.DEPLOY_SHA = sh(script: "cat .git_commit", returnStdout: true).trim()
      currentBuild.description = "Promote ${params.PROMOTE_TO} @ ${env.DEPLOY_SHA}"
      echo "Deploying commit: ${env.DEPLOY_SHA}"
    }
  }
}

    stage('Select Environment') {
      steps {
        script {
          env.TF_DIR    = "infra/envs/${params.PROMOTE_TO}"
          env.TFVARS    = "${params.PROMOTE_TO}.tfvars"
          env.PLAN_FILE = "tfplan-${params.PROMOTE_TO}.out"
        }
        sh """
          set -e
          test -d "${env.TF_DIR}"
          ls -la "${env.TF_DIR}"
        """
      }
    }

    stage('Terraform Init') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'arr-lab-aws']]) {
          sh """
            set -e
            cd "${env.TF_DIR}"
            export AWS_DEFAULT_REGION='${params.AWS_REGION}'
            aws sts get-caller-identity
            terraform init -reconfigure
          """
        }
      }
    }

    stage('Terraform Plan') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'arr-lab-aws']]) {
          sh """
            set -e
            cd "${env.TF_DIR}"
            export AWS_DEFAULT_REGION='${params.AWS_REGION}'
            terraform validate
            terraform plan -var-file="${env.TFVARS}" -out="${env.PLAN_FILE}"
          """
        }
      }
    }

    stage('Approval') {
      steps {
        script {
          if (!params.AUTO_APPROVE) {
            input message: "Apply to ${params.PROMOTE_TO.toUpperCase()} from commit ${env.DEPLOY_SHA}?", ok: "Apply"
          } else if (params.PROMOTE_TO == 'prod') {
            error("AUTO_APPROVE is not allowed for prod. Uncheck it.")
          }
        }
      }
    }

    stage('Terraform Apply') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'arr-lab-aws']]) {
          sh """
            set -e
            cd "${env.TF_DIR}"
            export AWS_DEFAULT_REGION='${params.AWS_REGION}'
            terraform apply -auto-approve "${env.PLAN_FILE}"
          """
        }
      }
    }
  }
}
